import { getDb, DbResult } from '@/lib/db'
import { guardQuery } from '@/lib/query-guard'
import { mysqlToSqlite } from '@/lib/mysql-compat'
import { checkRateLimit } from '@/lib/rate-limit'

const MAX_ROWS = 200

export async function POST(request: Request) {
  // Rate limiting
  const ip =
    request.headers.get('x-forwarded-for')?.split(',')[0].trim() ??
    request.headers.get('x-real-ip') ??
    '127.0.0.1'

  const { allowed, retryAfter } = checkRateLimit(ip)
  if (!allowed) {
    return Response.json(
      { error: 'Rate limit exceeded. Try again shortly.' },
      { status: 429, headers: { 'Retry-After': String(retryAfter) } }
    )
  }

  // Parse body
  let body: { sql?: unknown }
  try {
    body = await request.json()
  } catch {
    return Response.json({ error: 'Invalid JSON body' }, { status: 400 })
  }

  const raw = body.sql
  if (typeof raw !== 'string' || !raw.trim()) {
    return Response.json({ error: 'Missing or empty sql field' }, { status: 400 })
  }

  // Translate MySQL syntax → SQLite, split into individual statements
  const { statements } = mysqlToSqlite(raw)

  if (statements.length === 0) {
    return Response.json({ error: 'Empty query' }, { status: 400 })
  }

  // Execute each statement in sequence.
  // - internal: generated by the translation layer (PRAGMA, sqlite_master) — bypass guard
  // - non-internal: user-written — must pass the query guard
  try {
    const db = await getDb()
    let lastResult: DbResult = { columns: [], rows: [] }

    for (const { sql, internal } of statements) {
      if (internal) {
        const result = await db.execute(sql)
        if (result.columns.length > 0) lastResult = result
      } else {
        const guard = guardQuery(sql)
        if (!guard.safe) {
          return Response.json({ error: guard.error }, { status: 400 })
        }
        const result = await db.execute(guard.sql)
        if (result.columns.length > 0) lastResult = result
      }
    }

    const rows = lastResult.rows.slice(0, MAX_ROWS)
    return Response.json({
      columns: lastResult.columns,
      rows,
      truncated: lastResult.rows.length > MAX_ROWS,
    })
  } catch (err) {
    return Response.json({ error: String(err) }, { status: 500 })
  }
}
