/**
 * Translates common MySQL-specific syntax to SQLite-compatible equivalents.
 * Applied before the query guard. Covers what a typical intro database class uses.
 *
 * Statements generated by this translation (PRAGMA, sqlite_master queries) are
 * marked `internal: true` so the route can bypass the query guard for them.
 */

export interface TranslatedStatement {
  sql: string
  /** True when this statement was generated by the translation layer, not typed by the user.
   *  Internal statements bypass the query guard since we produced them. */
  internal: boolean
}

export interface CompatResult {
  statements: TranslatedStatement[]
}

export function mysqlToSqlite(raw: string): CompatResult {
  const stmts = splitOnSemicolons(raw)
  const statements: TranslatedStatement[] = []
  for (const stmt of stmts) {
    const trimmed = stmt.trim()
    if (!trimmed) continue
    const result = translateOne(trimmed)
    if (result !== null) statements.push(result)
  }
  return { statements }
}

// ---------------------------------------------------------------------------
// Per-statement translation
// ---------------------------------------------------------------------------

function translateOne(stmt: string): TranslatedStatement | null {
  // DROP DATABASE ... → skip (SQLite has no databases)
  if (/^DROP\s+DATABASE\b/i.test(stmt)) return null

  // CREATE DATABASE ... → skip
  if (/^CREATE\s+DATABASE\b/i.test(stmt)) return null

  // USE <dbname> → skip (SQLite has one DB per file)
  if (/^USE\s+\w+\s*$/i.test(stmt)) return null

  // SHOW DATABASES → skip
  if (/^SHOW\s+DATABASES\s*$/i.test(stmt)) return null

  // SHOW TABLES → sqlite_master query
  if (/^SHOW\s+TABLES\s*$/i.test(stmt)) {
    return {
      sql: "SELECT name AS Tables FROM sqlite_master WHERE type='table' AND name NOT LIKE 'sqlite_%' ORDER BY name",
      internal: true,
    }
  }

  // DESCRIBE <table> / DESC <table>
  const descMatch = stmt.match(/^(?:DESCRIBE|DESC)\s+(`?\w+`?)\s*$/i)
  if (descMatch) {
    const table = descMatch[1].replace(/`/g, '')
    return { sql: `PRAGMA table_info(${table})`, internal: true }
  }

  // SHOW COLUMNS FROM <table>
  const showColMatch = stmt.match(/^SHOW\s+COLUMNS\s+FROM\s+(`?\w+`?)\s*$/i)
  if (showColMatch) {
    const table = showColMatch[1].replace(/`/g, '')
    return { sql: `PRAGMA table_info(${table})`, internal: true }
  }

  // CREATE TABLE: apply DDL-level translations
  if (/^CREATE\s+(?:TEMPORARY\s+)?TABLE\b/i.test(stmt)) {
    return { sql: translateCreateTable(stmt), internal: false }
  }

  // Everything else: apply general syntax translations
  return { sql: translateGeneral(stmt), internal: false }
}

// ---------------------------------------------------------------------------
// CREATE TABLE translation
// ---------------------------------------------------------------------------

function translateCreateTable(sql: string): string {
  let s = sql

  // Remove table-level options that appear after the closing ')':
  // ENGINE=InnoDB, DEFAULT CHARSET=utf8mb4, AUTO_INCREMENT=100, COLLATE=..., etc.
  s = s.replace(
    /\)\s*((?:ENGINE|AUTO_INCREMENT|DEFAULT\s+CHARSET|CHARSET|CHARACTER\s+SET|COLLATE|ROW_FORMAT)\s*=\s*\S+\s*)*(;?\s*)$/i,
    ')'
  )

  // Remove column-level AUTO_INCREMENT (SQLite INTEGER PRIMARY KEY auto-increments)
  s = s.replace(/\bAUTO_INCREMENT\b/gi, '')

  // Remove UNSIGNED, ZEROFILL (SQLite has no unsigned types)
  s = s.replace(/\b(?:UNSIGNED|ZEROFILL)\b/gi, '')

  // Remove CHARACTER SET ... and COLLATE ... in column definitions
  s = s.replace(/\bCHARACTER\s+SET\s+\w+\b/gi, '')
  s = s.replace(/\bCOLLATE\s+[\w_]+\b/gi, '')

  // Remove COMMENT '...' in column definitions
  s = s.replace(/\bCOMMENT\s+'(?:[^'\\]|\\.)*'/gi, '')

  // Remove inline KEY / INDEX definitions (must be separate CREATE INDEX in SQLite)
  s = s.replace(/,\s*(?:UNIQUE\s+)?(?:INDEX|KEY)\s+\w+\s*\([^)]+\)/gi, '')
  s = s.replace(/,\s*(?:UNIQUE\s+)?(?:INDEX|KEY)\s*\([^)]+\)/gi, '')

  // ENUM(...) / SET('a','b',...) → TEXT
  s = s.replace(/\bENUM\s*\([^)]*\)/gi, 'TEXT')
  s = s.replace(/\bSET\s*\(\s*'[^)]*\)/gi, 'TEXT')

  // Type mappings (SQLite uses INTEGER, REAL, TEXT, BLOB, NUMERIC)
  s = s.replace(/\bTINYINT(?:\s*\(\d+\))?\b/gi, 'INTEGER')
  s = s.replace(/\bSMALLINT(?:\s*\(\d+\))?\b/gi, 'INTEGER')
  s = s.replace(/\bMEDIUMINT(?:\s*\(\d+\))?\b/gi, 'INTEGER')
  s = s.replace(/\bBIGINT(?:\s*\(\d+\))?\b/gi, 'INTEGER')
  s = s.replace(/\bDOUBLE(?:\s+PRECISION)?(?:\s*\(\d+\s*,\s*\d+\))?\b/gi, 'REAL')
  s = s.replace(/\bFLOAT(?:\s*\(\d+\s*,\s*\d+\))?\b/gi, 'REAL')
  s = s.replace(/\bDATETIME(?:\s*\(\d+\))?\b/gi, 'TEXT')
  s = s.replace(/\bTIMESTAMP(?:\s*\(\d+\))?\b/gi, 'TEXT')
  s = s.replace(/\b(?:TINY|MEDIUM|LONG)TEXT\b/gi, 'TEXT')
  s = s.replace(/\b(?:TINY|MEDIUM|LONG)BLOB\b/gi, 'BLOB')
  s = s.replace(/\b(?:BOOLEAN|BOOL)\b/gi, 'INTEGER')

  // Backtick identifiers → plain (SQLite uses double-quotes, but unquoted works for simple names)
  s = s.replace(/`(\w+)`/g, '$1')

  return s
}

// ---------------------------------------------------------------------------
// General statement translation (DML, SELECT, etc.)
// ---------------------------------------------------------------------------

function translateGeneral(sql: string): string {
  let s = sql

  // Backtick identifiers → plain
  s = s.replace(/`(\w+)`/g, '$1')

  // INSERT IGNORE → INSERT OR IGNORE
  s = s.replace(/\bINSERT\s+IGNORE\b/gi, 'INSERT OR IGNORE')

  // MySQL date/time functions → SQLite equivalents
  s = s.replace(/\bNOW\s*\(\s*\)/gi, "datetime('now')")
  s = s.replace(/\bCURDATE\s*\(\s*\)/gi, "date('now')")
  s = s.replace(/\bCURTIME\s*\(\s*\)/gi, "time('now')")

  // MySQL LIMIT offset, count → LIMIT count OFFSET offset
  s = s.replace(/\bLIMIT\s+(\d+)\s*,\s*(\d+)\b/gi, 'LIMIT $2 OFFSET $1')

  return s
}

// ---------------------------------------------------------------------------
// Statement splitter (respects single-quoted strings and strips comments)
// ---------------------------------------------------------------------------

function splitOnSemicolons(sql: string): string[] {
  // Strip comments first so we don't split on semicolons inside them
  const stripped = sql
    .replace(/--[^\n]*/g, ' ')
    .replace(/\/\*[\s\S]*?\*\//g, ' ')

  const stmts: string[] = []
  let current = ''
  let inString = false

  for (let i = 0; i < stripped.length; i++) {
    const ch = stripped[i]
    if (ch === "'" && stripped[i - 1] !== '\\') inString = !inString
    if (!inString && ch === ';') {
      const trimmed = current.trim()
      if (trimmed) stmts.push(trimmed)
      current = ''
    } else {
      current += ch
    }
  }

  const last = current.trim()
  if (last) stmts.push(last)
  return stmts.length > 0 ? stmts : [sql.trim()]
}
